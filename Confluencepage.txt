def revoke_user_access(cursor, user_id, rmm_id):
    """
    Revoke user access by:
    1. Deactivating metric access using USER_ID + METRIC_DETAIL_ID
    2. Deactivating MAP_RAP_USER_ROLE using USER_ID + RMM_ID
    """

    try:
        logger_debug(
            f"[REVOKE] Starting revoke for USER_ID={user_id}, RMM_ID={rmm_id}"
        )

        # ------------------------------------------------
        # STEP 1: Fetch metric_detail_ids (already filtered
        #         by RMM_ID + current month in earlier query)
        # ------------------------------------------------
        cursor.execute("""
            SELECT METRIC_DETAIL_ID
            FROM <YOUR_METRIC_DETAIL_QUERY_SOURCE>
            WHERE USER_ID = :user_id
              AND RMM_ID = :rmm_id
        """, {
            "user_id": user_id,
            "rmm_id": rmm_id
        })

        metric_detail_ids = [row[0] for row in cursor.fetchall()]

        if not metric_detail_ids:
            logger_debug(
                f"[REVOKE] No metrics found for USER_ID={user_id}, RMM_ID={rmm_id}"
            )
        else:
            logger_debug(
                f"[REVOKE] Deactivating {len(metric_detail_ids)} metrics "
                f"for USER_ID={user_id}"
            )

            # ------------------------------------------------
            # STEP 2: Bulk deactivate metric access
            # ------------------------------------------------
            cursor.execute(f"""
                UPDATE METRIC_ACCESS
                SET IS_ACTIVE = 0
                WHERE USER_ID = :user_id
                  AND METRIC_DETAIL_ID IN ({','.join(map(str, metric_detail_ids))})
                  AND IS_ACTIVE = 1
            """, {"user_id": user_id})

            logger_debug(
                f"[REVOKE] Metric access rows updated: {cursor.rowcount}"
            )

        # ------------------------------------------------
        # STEP 3: Deactivate MAP_RAP_USER_ROLE
        # ------------------------------------------------
        cursor.execute("""
            UPDATE MAP_RAP_USER_ROLE
            SET IS_ACTIVE = 0
            WHERE USER_ID = :user_id
              AND RMM_ID = :rmm_id
              AND IS_ACTIVE = 1
        """, {
            "user_id": user_id,
            "rmm_id": rmm_id
        })

        logger_debug(
            f"[REVOKE] MAP_RAP_USER_ROLE deactivated for "
            f"USER_ID={user_id}, RMM_ID={rmm_id}"
        )

    except Exception as e:
        logger_error(
            f"[REVOKE][ERROR] Failed revoke for USER_ID={user_id}, "
            f"RMM_ID={rmm_id} | {str(e)}"
        )
        raise
==============================================
def update_data(self, sqlQry, parm):
    try:
        print("in update_data")
        print(sqlQry)
        print(parm)

        if isinstance(parm, list):
            # NEW: support bulk updates
            self.__cursor.executemany(sqlQry, parm)
        else:
            self.__cursor.execute(sqlQry, parm)

        self.__con.commit()
        return 0

    except Exception as e:
        log_error.error("Error | update_data | Error: %s", e, exc_info=True)
        return -1

===============================================

def sqlinsertdata__ur(self, query_key, placeholder_list, param):
    """
    Generic INSERT / UPDATE executor
    - Supports single row
    - Supports bulk rows
    - Uses existing update_data()
    """

    try:
        # 1. Build placeholders string
        # Example: :1,:2,:3 OR :user_id,:metric_detail_id
        placeholders_id = ', '.join(placeholder_list)

        # 2. Prepare SQL
        sqlQry = QueryString[query_key]['QString'].format(placeholders_id)

        log_debug.debug("Executing SQL:")
        log_debug.debug(sqlQry)
        log_debug.debug(f"Params: {param}")

        # 3. Delegate execution
        Db_Con.update_data(sqlQry, param)

        return 0

    except Exception as e:
        log_error.error(
            f"Error | sqlinsertdata__ur | {str(e)}",
            exc_info=True
        )
        return -1

======================================================

UPDATE METRIC_ACCESS
SET IS_ACTIVE = 0
WHERE USER_ID = :user_id
  AND METRIC_DETAIL_ID = :metric_detail_id
  AND IS_ACTIVE = 1




====================
final

def sqlupdatedata(self, query_key, param):
    """
    Generic UPDATE executor
    - Supports single row
    - Supports bulk rows
    - Uses bulk_update_data
    """

    try:
        # 1. Fetch SQL directly (NO formatting)
        sqlQry = QueryString[query_key]['QString']

        log_debug.debug("Executing SQL:")
        log_debug.debug(sqlQry)
        log_debug.debug(f"Params: {param}")

        # 2. Delegate execution
        Db_Con.bulk_update_data(sqlQry, param)

        return 0

    except Exception as e:
        log_error.error(
            f"Error | sqlupdatedata | {str(e)}",
            exc_info=True
        )
        return -1



def bulk_update_data(self, sqlQry, parm):
    try:
        print("in bulk_update_data")
        print(sqlQry)
        print(parm)

        if isinstance(parm, list):
            self.__cursor.executemany(sqlQry, parm)
        else:
            self.__cursor.execute(sqlQry, parm)

        self.__con.commit()
        return 0

    except Exception as e:
        log_error.error("Error | bulk_update_data | Error: %s", e, exc_info=True)
        return -1



params = [
    {
        "user_id": user_id,
        "metric_detail_id": metric_id
    }
    for metric_id in metric_detail_ids
]
======================
row count

def bulk_update_data(self, sqlQry, parm):
    try:
        log_debug.debug("in bulk_update_data")
        log_debug.debug(sqlQry)

        total_requested = len(parm) if isinstance(parm, list) else 1
        log_debug.debug(f"Total rows requested for update: {total_requested}")

        if isinstance(parm, list):
            self.__cursor.executemany(sqlQry, parm)
        else:
            self.__cursor.execute(sqlQry, parm)

        affected = self.__cursor.rowcount
        self.__con.commit()

        log_debug.debug(
            f"bulk_update_data completed | "
            f"rows_updated={affected} | "
            f"rows_requested={total_requested}"
        )

        return affected  # ðŸ‘ˆ RETURN ROWCOUNT

    except Exception as e:
        log_error.error(
            "Error | bulk_update_data | Error: %s", e, exc_info=True
        )
        return -1
