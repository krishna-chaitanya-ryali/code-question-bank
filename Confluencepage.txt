from datetime import datetime
import cx_Oracle
from flask import Blueprint, jsonify
from apscheduler.schedulers.background import BackgroundScheduler

recert_bp = Blueprint('recertification', __name__)

# ---------------------------------
# 1. Oracle DB Connection Function
# ---------------------------------
def get_db_connection():
    return cx_Oracle.connect(
        user="YOUR_USERNAME",
        password="YOUR_PASSWORD",
        dsn="YOUR_DSN"
    )

# ---------------------------------
# 2. Core Recertification Worker
# ---------------------------------
def process_user_recertification():
    print("Scheduler started at:", datetime.now())

    conn = get_db_connection()
    cursor = conn.cursor()

    today = datetime.now().date()

    # Fetch all records that are REVOKE but future-dated
    fetch_query = """
        SELECT REPORTEES_ID,
               RMM_ID,
               ACCESS_STATUS,
               IS_ACTIVE,
               ACCESS_LEVEL,
               REVOKE_ON_DATE
        FROM RECREATE_RESPONSE
        WHERE ACCESS_STATUS = 'REVOKE'
          AND IS_ACTIVE = 0
          AND RMM_ID IS NOT NULL
    """

    cursor.execute(fetch_query)
    rows = cursor.fetchall()

    for row in rows:
        user_id      = row[0]
        rmm_id       = row[1]
        access_status = row[2]
        is_active     = row[3]
        access_level  = row[4]
        revoke_on_date = row[5]

        # --- 1. If no date provided, treat as immediate revoke ---
        if revoke_on_date is None:
            print(f"[INFO] No revoke date for {user_id}/{rmm_id}. Revoking immediately.")
            revoke_user_access(cursor, user_id, rmm_id)
            continue

        revoke_date = revoke_on_date.date()

        # --- 2. If future date, skip until the date arrives ---
        if today < revoke_date:
            print(f"[SKIP] {user_id}/{rmm_id} scheduled for future revoke on {revoke_date}")
            continue

        # --- 3. Today >= revoke date â†’ revoke now ---
        print(f"[REVOKE] Revoking access for {user_id}/{rmm_id} on {today}")
        revoke_user_access(cursor, user_id, rmm_id)

    conn.commit()
    cursor.close()
    conn.close()
    print("Scheduler completed at:", datetime.now())


# -------------------------------------------------------
# 3. Actual revocation worker (Delete + Update isActive)
# -------------------------------------------------------
def revoke_user_access(cursor, user_id, rmm_id):
    
    # 1. UPDATE isActive = 1 in RECREATE_RESPONSE
    update_query = """
        UPDATE RECREATE_RESPONSE
        SET IS_ACTIVE = 1
        WHERE REPORTEES_ID = :user_id
          AND RMM_ID = :rmm_id
          AND ACCESS_STATUS = 'REVOKE'
    """

    cursor.execute(update_query, {"user_id": user_id, "rmm_id": rmm_id})

    # 2. DELETE specific RMM access (not all locations)
    delete_query = """
        DELETE FROM MAP_RAP_USER_ROLE
        WHERE USER_ID = :user_id
          AND RMM_ID = :rmm_id
    """

    cursor.execute(delete_query, {"user_id": user_id, "rmm_id": rmm_id})


# ---------------------------------
# 4. Scheduler Registration (Daily/Hourly)
# ---------------------------------
def init_scheduler(app):
    scheduler = BackgroundScheduler()
    scheduler.add_job(func=process_user_recertification,
                      trigger="interval",
                      hours=1,  # RUN EVERY HOUR
                      id="user_recertification_job",
                      replace_existing=True)
    scheduler.start()
    print("Scheduler initialized successfully.")


# ---------------------------------
# 5. Manual Trigger Endpoint
# ---------------------------------
@recert_bp.route("/trigger-recertification", methods=["POST"])
def manual_trigger():
    process_user_recertification()
    return jsonify({"status": "Manual trigger executed successfully"})
